[gd_scene load_steps=4 format=3 uid="uid://br73vw45bjrdn"]

[sub_resource type="GDScript" id="GDScript_bt08i"]
script/source = "extends Node2D
\"\"\"
Feast Machine test
World 
	-This array contains all the Cells in the world
	
Neighbor
	-Lookup table for neighbors of a the cell at the corresponding index
	
Cell
	-Contains a reference to the contents of the cell
	-This allows a reference to be created to the Cell 
	 so that it can be stored in the neighbor array
	
Atoms 
	-Atoms provide blueprints and stats for how the atom behaves
	-Operates atomically, within its own world and parameters
	
	
TODO
	-Maybe add bitboards
	-Add cell types
\"\"\"

# 4 0 6
# 2 @ 3
# 7 1 5

@export_node_path(\"Sprite2D\") var sprite_path
@onready var sprite : = get_node(sprite_path)

@export var sim_size : = Vector2i(100, 100) 
@export var disabled : = false

@onready var image : = Image.create(sim_size.x, sim_size.y, false, Image.FORMAT_RGB8)

var world : = []
var neighbors : = []
var bitboards : = []

var cells_updated : = []

var coords : = []
var coords_index : = 0

enum TYPE {
	EMPTY,
	SAND,
	WANDER,
	STONE,
	WATER,
	MAX,
}
var neighbor_offsets : = [
	Vector2i.UP,
	Vector2i.DOWN,
	Vector2i.LEFT,
	Vector2i.RIGHT,
	Vector2i.UP + Vector2i.LEFT,
	Vector2i.UP + Vector2i.RIGHT,
	Vector2i.DOWN + Vector2i.LEFT,
	Vector2i.DOWN + Vector2i.RIGHT,
]

var event_window : = []

func _ready():
	if disabled:
		return
	#Set up event window
	event_window = grid_circle(4)
	
	#Background fill on image
	image.fill(Color.WEB_GRAY)
	var new_image_tex : = ImageTexture.create_from_image(image)
	sprite.texture = new_image_tex
	#Generate Cells
	world.resize(sim_size.x)
	for x in sim_size.x:
		world[x] = []
	for array in world:
		array.resize(sim_size.y)
	for x in sim_size.x:
		for y in sim_size.y:
			world[x][y] = Cell.new()
	#Generate neighbor array
	neighbors.resize(sim_size.x)
	for x in sim_size.x:
		neighbors[x] = []
	for array in neighbors:
		array.resize(sim_size.y)
	for x in sim_size.x:
		for y in sim_size.y:
			var current_pos : = Vector2i(x,y)
			var neighbors_dict : = {}
			var directions_to_add : = event_window
			for dir in directions_to_add:
				neighbors_dict[dir] = \\
					null if not is_in_bounds(Vector2i(x,y) + dir) \\
					else world[x + dir.x][y + dir.y]
			neighbors[x][y] = neighbors_dict
	#Generate randomly ordered coordinates array
	for x in sim_size.x:
		for y in sim_size.y:
			var current_pos : = Vector2i(x,y)
			coords.append(current_pos)
	coords.shuffle()
#	coords.sort_custom(func (a,b): return a.y > b.y)

	#Setup bitboards
	for cell_type in range(1):#TYPE.MAX):
		var bitboard : = BitMap.new()
		bitboard.create(sim_size)
		var sprite : = $Bitboard
		sprite.texture = ImageTexture.create_from_image(bitboard.convert_to_image())
		bitboards.append(bitboard)
	##Debug view for bitboards

	#Fill world
	for x in sim_size.x:
		for y in sim_size.y:
			var rand_num : = randf()
			if rand_num < 0.5:
				world[x][y].content = Atom.new()
			elif rand_num < 0.9:
				world[x][y].content = Sand.new()
				bitboards[0].set_bit(x,y, true)
			else:
#				world[x][y].content = Wander.new()
				world[x][y].content = Atom.new()
	
func _input(event):
	if disabled:
		return
		
	if Input.is_action_pressed(\"ui_accept\"):
		add_cell(get_global_mouse_position()/sprite.scale, 2, TYPE.STONE)
	if Input.is_key_pressed(KEY_C):
		add_cell(get_global_mouse_position()/sprite.scale, 2)
	if Input.is_key_pressed(KEY_X):
		add_cell(get_global_mouse_position()/sprite.scale, 2, TYPE.WANDER)
#	if Input.is_action_just_pressed(\"up\"):
#		var bitboard : BitMap = bitboards[0]
#		bitboard.grow_mask(1, Rect2i(120/3, 67/3, 50, 50))
#	if Input.is_action_just_pressed(\"down\"):
#		var bitboard : BitMap = bitboards[0]
#		bitboard.grow_mask(-1, Rect2i(120/3, 67/3, 50, 50))
	
func _process(delta):
	if disabled:
		return
	draw_cells()
	calculate_cells()
	$Bitboard.texture.update(bitboards[0].convert_to_image())
	
	
func calculate_cells():
	for _i in range(1000):
		var cell_position : Vector2i = coords[coords_index]
		coords_index = wrapi(coords_index + 1, 0, coords.size())
		var current_cell : Cell = world[cell_position.x][cell_position.y]
		
		##TODO: change this to use bitboards and check against cell rules
		#		call act on cell for basic behavior (movement)
		#		call react on cell for specialized behavior (cell interactions)
		
#		cells_updated.append(cell_position)
		match current_cell.content.type:
			TYPE.SAND:
				var side : = [Vector2i.RIGHT, Vector2i.LEFT]
				side.shuffle()
				var directions : = [
					Vector2i.DOWN, 
					Vector2i.DOWN + side[0],
					Vector2i.DOWN + side[1],
				]
				for dir in directions:
					var dir_cell : Cell = neighbors[cell_position.x][cell_position.y][dir]
					if dir_cell != null and current_cell.content.density > dir_cell.content.density:
						swap_cells(cell_position, cell_position + dir)
						break
			TYPE.WANDER:
				var directions : = [
					Vector2i.UP,
					Vector2i.DOWN, 
					Vector2i.LEFT,
					Vector2i.RIGHT,
				]
				directions.shuffle()
				for dir in directions:
					var dir_cell : Cell = neighbors[cell_position.x][cell_position.y][dir]
					if dir_cell != null:
						#Wander
						swap_cells(cell_position, cell_position + dir)
						#Density sharing
						if current_cell.content is Wander:
							current_cell.content.act(neighbors[cell_position.x][cell_position.y])
							var dir_atom : Wander = dir_cell.content
#							if dir_atom.light < current_cell.content.light:
#								dir_atom.light = current_cell.content.light - 1.0
#								dir_atom.light = randf() * current_cell.content.light
						break
			TYPE.STONE:
				var atom : Stone= current_cell.content 
				
#				var falling : = false
				if atom.sleeping:
					var cell_below : Cell = neighbors[cell_position.x][cell_position.y][Vector2i.DOWN]
					if cell_below != null and atom.density > cell_below.content.density:
#						swap_cells(cell_position, cell_position + Vector2i.DOWN)
#						falling = true
						atom.sleeping = false
					else:
						var directions : = neighbor_offsets
						for dir in directions:
							if cells_updated.has(cell_position + dir):
	#							if randf() > atom.inertia:
									atom.sleeping = false
	#								falling = true
#				atom.sleeping = not falling 
				if not atom.sleeping:
					var side : = [Vector2i.RIGHT, Vector2i.LEFT]
					side.shuffle()
					var directions : = [
						Vector2i.DOWN,
						Vector2i.DOWN + side[0],
						Vector2i.DOWN + side[1],
					]
					var sleeping : = true
					for dir in directions:
						var dir_cell : Cell = neighbors[cell_position.x][cell_position.y][dir]
						if dir_cell != null and current_cell.content.density > dir_cell.content.density:
							swap_cells(cell_position, cell_position + dir)
							sleeping = false
							break
					atom.sleeping = sleeping
				draw_cell(cell_position)
					
			TYPE.EMPTY, TYPE.MAX, _:
				draw_cell(cell_position)
#				cells_updated.append(cell_position)
				pass
		
func draw_cells():
	for _i in cells_updated.size():
		draw_cell(cells_updated.pop_back())
	sprite.texture.update(image)
	

func draw_cell(pos : Vector2i):
	var cell : Cell = world[pos.x][pos.y]
	match cell.content.type:
		TYPE.WANDER:
			image.set_pixelv(pos, Color8(
				int(cell.content.light * 2),
				int(cell.content.light * 2),
				int(cell.content.light * 2),
			))
		TYPE.SAND:
			image.set_pixelv(pos, Color8(
				cell.content.type * 128, 
				cell.content.density * 16, 
				cell.content.density * 16,
			))
		TYPE.STONE:
			image.set_pixelv(pos, Color8(
				cell.content.type * 128, 
				cell.content.density * 16, 
				int(cell.content.sleeping) * 255,
			))
		TYPE.EMPTY, _:
			image.set_pixelv(pos, Color.BLACK)
		
func add_cell(pos : Vector2i, radius : = 0, type : = TYPE.EMPTY):
	var new_atom : Atom
	match type:
		TYPE.SAND:
			new_atom = Sand.new()
		TYPE.STONE:
			new_atom = Stone.new()
		TYPE.WANDER:
			new_atom = Wander.new()
		_:
			new_atom = Atom.new()
			
	for p in grid_circle(radius):
		world[pos.x + p.x][pos.y + p.y].content = new_atom
		
func swap_cells(pos1 : Vector2i, pos2 : Vector2i):
	var cell1 : Cell = world[pos1.x][pos1.y]
	var cell2 : Cell = world[pos2.x][pos2.y]
	var temp : Atom = cell1.content
	cell1.content = cell2.content
	cell2.content = temp
	cells_updated.append(pos1)
	cells_updated.append(pos2)
	if cell1.content.type == TYPE.SAND and cell2.content.type != TYPE.SAND:
		bitboards[0].set_bit(pos1.x, pos1.y, false)
		bitboards[0].set_bit(pos2.x, pos2.y, true)
	elif cell2.content.type == TYPE.SAND and cell1.content.type != TYPE.SAND:
		bitboards[0].set_bit(pos2.x, pos2.y, false)
		bitboards[0].set_bit(pos1.x, pos1.y, true)
#	for neighbor in neighbors[pos1.x][pos1.y].values():
#		if neighbor != null and neighbor.content.type == TYPE.STONE:
#			neighbor.content.sleeping = false
	
func grid_circle(radius : int) -> Array:
	var array : = []
	for y in range(-radius, radius + 1):
		var dx : float = sqrt(radius*radius - y*y)
		var left_bound : int = ceil(-dx)
		var right_bound : int = floor(dx)
		for x in range(left_bound, right_bound + 1):
			array.append(Vector2i(x,y))
			
	return array
	
func is_in_bounds(pos : Vector2i) -> bool:
	return pos.x >= 0 and pos.y  >= 0 and pos.x < sim_size.x and pos.y < sim_size.y
	
class Cell extends RefCounted:
	var content : Atom

class Sand extends Atom:
	func _init():
		pass
		#type = 1
		#density = 5
		
class Wander extends Atom:
	var light : = 50.0
#
	#func _init():
		#type = 2
		#density = 1
		
	func act(neighbors : Dictionary):
		if randf() > 0.999:
			light = randf() * 100
		else:
			light -= 25.0
		#for cell in neighbors.values():
			#if cell != null:
				#if cell.content.type == type and cell.content.light < light:
					#if randf() > 0.8:
						#cell.content.light = light - 10.0
								
class Stone extends Atom:
	var sleeping : = false
	var inertia : = 0.9
	var height : = 4
	
	#func _init():
		#type = TYPE.STONE
		#density = 10
		#inertia = 0.1
		
	func act():
		pass
	
		
	
"

[sub_resource type="PlaceholderTexture2D" id="PlaceholderTexture2D_s3ury"]
size = Vector2(120, 67)

[sub_resource type="PlaceholderTexture2D" id="PlaceholderTexture2D_qes51"]
size = Vector2(120, 67)

[node name="feast_machine" type="Node2D"]
script = SubResource("GDScript_bt08i")
sprite_path = NodePath("Display")
sim_size = Vector2i(120, 67)

[node name="Display" type="Sprite2D" parent="."]
texture_filter = 1
scale = Vector2(4, 4)
texture = SubResource("PlaceholderTexture2D_s3ury")
centered = false

[node name="Bitboard" type="Sprite2D" parent="."]
position = Vector2(480, 0)
texture = SubResource("PlaceholderTexture2D_qes51")
centered = false

[node name="Camera2D" type="Camera2D" parent="."]
position = Vector2(300, 175)
zoom = Vector2(2, 2)

[node name="Cells" type="Node2D" parent="."]

[node name="Bitboards" type="Node2D" parent="Cells"]

[node name="Sand" type="Node2D" parent="Cells"]

[node name="Stats" type="Node2D" parent="Cells/Sand"]

[node name="Act or Rules" type="Node2D" parent="Cells/Sand"]
